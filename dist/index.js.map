{
  "version": 3,
  "sources": ["../node_modules/classnames/index.js", "../src/map.tsx", "../src/extend-context.ts", "../src/marker.tsx", "../src/drop-zone.tsx", "../src/tooltip.tsx"],
  "sourcesContent": ["/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\tvar nativeCodeString = '[native code]';\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n", "import React, { useRef, useState, useMemo, useCallback, useEffect } from \"react\";\n\nimport { extendContext } from \"./extend-context\";\nimport { Marker } from \"./marker\";\nimport { DropZone } from \"./drop-zone\";\nimport { Tooltip } from \"./tooltip\";\nimport type { Coords } from \"./types\";\n\nconst SCALE_FACTOR = 1.1;\nconst KEYDOWN_ESCAPE = 27;\n\ntype MapProps = {\n  image: string;\n  children?: React.ReactNode;\n\n  onClick?(pt: Coords): void;\n  onDoubleClick?(pt: Coords): void;\n  onCursorMove?(pt: Coords): void;\n\n  minZoom?: number;\n  maxZoom?: number;\n  overpan?: number;\n\n  minDragTime?: number;\n  clickGraceTime?: number;\n\n  containInitialImage?: boolean; // begin with zoom/translation that contains initial image\n  containUpdatedImage?: boolean; // update zoom/translation to contain a change of image\n  allowContainmentZoom?: boolean; // allow zooming beyond min/max if image is not contained\n\n  panTo?: Coords;\n};\n\ntype ScreenPositionCoords = {\n  topLeft?: Coords;\n  bottomRight?: Coords;\n  valid: boolean;\n};\n\nconst Map = React.forwardRef<HTMLCanvasElement, MapProps>(\n  (\n    {\n      image,\n      children,\n\n      onClick,\n      onDoubleClick,\n      onCursorMove,\n\n      minZoom = 0.2,\n      maxZoom = 5,\n      overpan = 30,\n\n      minDragTime = 300,\n      clickGraceTime = 100,\n\n      containInitialImage = true,\n      containUpdatedImage = true,\n      allowContainmentZoom = true,\n\n      panTo,\n    },\n    ref\n  ) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const mapImage = useRef<HTMLImageElement>();\n    const mapImageValid = useRef<boolean>(false);\n\n    const dragged = useRef(false);\n    const draggingMarkerKey = useRef<string | null>(null);\n    const dragTimeout = useRef<number | undefined>(undefined);\n    const clickPoint = useRef<DOMPoint | null>(null);\n    const clickTime = useRef(+new Date());\n    const cursor = useRef<Coords | null>(null);\n    const updateMouseCoords = useCallback(() => {\n      if (!canvasRef.current) {\n        return;\n      }\n      const context = extendContext(canvasRef.current.getContext(\"2d\"));\n      if (!context) {\n        return;\n      }\n      if (cursor.current && typeof onCursorMove === \"function\") {\n        onCursorMove(context.transformedPoint(cursor.current.x, cursor.current.y));\n      }\n    }, [onCursorMove]);\n\n    const animationActive = useRef(false);\n    const animationCancel = useRef(false);\n    const animationStart = useRef<number | null>(null);\n    const animationCoords = useRef<Coords | null>(null);\n    const animationLastTimestamp = useRef(+new Date());\n\n    const markers = useRef<React.ReactElement[]>([]);\n    const dropZones = useRef<React.ReactElement[]>([]);\n    const flatChildren = useMemo(() => {\n      const allChildren: React.ReactElement[] = [];\n      const getChildren = (child: React.ReactNode) => {\n        if (Array.isArray(child)) {\n          child.forEach(getChildren);\n        } else {\n          const asElement = child as React.ReactElement;\n          if (asElement) {\n            if (asElement.props && asElement.props.children && asElement.type !== Tooltip) {\n              getChildren(asElement.props.children);\n            } else {\n              allChildren.push(asElement);\n            }\n          }\n        }\n      };\n      getChildren(children);\n      return allChildren;\n    }, [children]);\n    markers.current = flatChildren.filter((child) => child.type && child.type === Marker);\n    const getMarkerChild = (key: string): React.ReactElement | undefined =>\n      markers.current.find((child) => child && child.props.markerKey === key);\n    dropZones.current = flatChildren.filter((child) => child.type && child.type === DropZone);\n    const tooltipChildren = useMemo(\n      () => flatChildren.filter((child) => child.type && child.type === Tooltip),\n      [flatChildren]\n    );\n\n    const getCursorCoords = () => {\n      if (!canvasRef.current) {\n        return null;\n      }\n      const context = extendContext(canvasRef.current.getContext(\"2d\"));\n      if (!context) {\n        return null;\n      }\n      if (cursor.current) {\n        return context.transformedPoint(cursor.current.x, cursor.current.y);\n      }\n      return null;\n    };\n    const getScreenPositionCoords = ({\n      right,\n      left,\n      top,\n      bottom,\n      width,\n      height,\n    }: {\n      right?: number;\n      left?: number;\n      top?: number;\n      bottom?: number;\n      width: number;\n      height: number;\n    }) => {\n      if (!canvasRef.current) {\n        return { valid: false } as ScreenPositionCoords;\n      }\n      const rect = canvasRef.current.getBoundingClientRect();\n      const context = extendContext(canvasRef.current.getContext(\"2d\"));\n      if (!context) {\n        return { valid: false } as ScreenPositionCoords;\n      }\n\n      let topLeft = { x: 0, y: 0 };\n      let bottomRight = { x: 100, y: 100 };\n      if (typeof top === \"number\") {\n        topLeft.y = top;\n        bottomRight.y = topLeft.y + height;\n      } else if (typeof bottom === \"number\") {\n        topLeft.y = rect.height - bottom - height;\n        bottomRight.y = topLeft.y + height;\n      } else {\n        return { valid: false } as ScreenPositionCoords; // no valid top/bottom dimensions\n      }\n      if (typeof left === \"number\") {\n        topLeft.x = left;\n        bottomRight.x = topLeft.x + width;\n      } else if (typeof right === \"number\") {\n        topLeft.x = rect.width - right - width;\n        bottomRight.x = topLeft.x + width;\n      } else {\n        return { valid: false } as ScreenPositionCoords; // no valid left/right dimensions\n      }\n      topLeft = context.transformedPoint(topLeft.x, topLeft.y);\n      bottomRight = context.transformedPoint(bottomRight.x, bottomRight.y);\n      return { topLeft, bottomRight, valid: true } as ScreenPositionCoords;\n    };\n    const getDropZoneTouchingCursor = useCallback((): React.ReactElement | undefined => {\n      const pt = getCursorCoords();\n      if (pt === null) {\n        return undefined;\n      }\n      // go through dropzones and see if it has landed in any\n      let droppedZone: React.ReactElement | undefined;\n      dropZones.current.forEach((dropZone) => {\n        const { right, left, top, bottom, width, height } = dropZone.props;\n        const { topLeft, bottomRight, valid } = getScreenPositionCoords({\n          right,\n          left,\n          top,\n          bottom,\n          width,\n          height,\n        });\n        if (!valid) {\n          return;\n        }\n        if (pt.x >= topLeft!.x && pt.x <= bottomRight!.x && pt.y >= topLeft!.y && pt.y <= bottomRight!.y) {\n          droppedZone = dropZone;\n        }\n      });\n      return droppedZone;\n    }, []);\n    const getMarkerTouchingCursor = useCallback(() => {\n      if (!canvasRef.current) {\n        return null;\n      }\n      const context = extendContext(canvasRef.current.getContext(\"2d\"));\n      if (!context) {\n        return null;\n      }\n\n      type DistanceLookup = {\n        [key: string]: number;\n      };\n\n      const close: DistanceLookup = {};\n\n      const cursorPt = getCursorCoords();\n      if (cursorPt === null) {\n        return null;\n      }\n\n      markers.current.forEach((child) => {\n        const {\n          markerKey,\n          coords,\n\n          size = 100,\n          scaleWithZoom = true,\n\n          onClick: onMarkerClick,\n          onDoubleClick: onMarkerDoubleClick,\n\n          dragZoneScale = 1,\n          onDragTick,\n          onDragEnd,\n        } = child.props;\n        if (\n          !(\n            typeof onMarkerClick === \"function\" ||\n            typeof onMarkerDoubleClick === \"function\" ||\n            typeof onDragTick === \"function\" ||\n            typeof onDragEnd === \"function\"\n          )\n        ) {\n          return;\n        }\n        const HOVER_DIST = (size / 2) * dragZoneScale;\n        const HOVER_DIST_SQ = HOVER_DIST * HOVER_DIST;\n\n        let distSq;\n        if (scaleWithZoom) {\n          distSq = (coords.x - cursorPt.x) ** 2 + (coords.y - cursorPt.y) ** 2;\n        } else {\n          const beaconScreenPt = context.untransformedPoint(coords.x, coords.y);\n          distSq = (beaconScreenPt.x - cursor.current!.x) ** 2 + (beaconScreenPt.y - cursor.current!.y) ** 2;\n        }\n\n        if (distSq < HOVER_DIST_SQ) {\n          close[markerKey] = distSq;\n        }\n      });\n      let closestDist = -1;\n      let closest: string[] = [];\n      Object.keys(close).forEach((key) => {\n        const distSq = close[key];\n        if (closestDist === -1 || distSq < closestDist) {\n          closestDist = distSq;\n          closest = [];\n          closest.push(key);\n        } else if (distSq === closestDist) {\n          closest.push(key);\n        }\n      });\n      return closest[0] || null;\n    }, []);\n    const updateCursor = useCallback(() => {\n      if (!canvasRef.current) {\n        return;\n      }\n      const hovered = getMarkerTouchingCursor();\n      if (hovered) {\n        canvasRef.current.style.cursor = \"pointer\";\n      } else {\n        canvasRef.current.style.cursor = \"auto\";\n      }\n    }, [getMarkerTouchingCursor]);\n\n    const tooltipsRef = useRef<HTMLDivElement>(null);\n    const updateTooltips = () => {\n      if (!canvasRef.current || !tooltipsRef.current) {\n        return;\n      }\n      const canvasRect = canvasRef.current.getBoundingClientRect();\n      const context = extendContext(canvasRef.current.getContext(\"2d\"));\n      if (!context) {\n        return;\n      }\n      Array.from(tooltipsRef.current.children).forEach((child) => {\n        const domChild = child as HTMLElement;\n        const tooltipX = Number(domChild.dataset[\"x\"]);\n        const tooltipY = Number(domChild.dataset[\"y\"]);\n\n        const screenCoords = context.untransformedPoint(tooltipX, tooltipY);\n        const relativeX = screenCoords.x / canvasRect.width;\n        const relativeY = screenCoords.y / canvasRect.height;\n        domChild.style.setProperty(\"left\", `${relativeX * 100}%`);\n        domChild.style.setProperty(\"top\", `${relativeY * 100}%`);\n      });\n    };\n\n    const lastRedraw = useRef(+new Date());\n    const logRedraw = (reason: string) => {\n      return;\n      const nowMs = +new Date();\n      const idleMs = nowMs - lastRedraw.current;\n      lastRedraw.current = nowMs;\n      console.log(`redrawing for ${reason} after ${idleMs}`);\n    };\n    const redraw = useCallback(\n      (reason: string) => {\n        if (!canvasRef.current) {\n          return;\n        }\n        logRedraw(reason);\n        const context = extendContext(canvasRef.current.getContext(\"2d\"));\n        if (!context) {\n          return;\n        }\n\n        // Clear the entire canvas\n        const p1 = context.transformedPoint(0, 0);\n        const p2 = context.transformedPoint(canvasRef.current.width, canvasRef.current.height);\n        context.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);\n\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n        context.restore();\n\n        if (mapImage.current && mapImageValid.current) {\n          context.drawImage(mapImage.current, 0, 0, mapImage.current.width, mapImage.current.height);\n        }\n\n        const scale = Math.min(context.getTransform().a, context.getTransform().d);\n        const renderMarkers = (child: React.ReactElement) => {\n          const {\n            coords,\n            image: markerImage,\n\n            inCircle = false,\n            circleColour = \"#337ab7\",\n            size = 100,\n            scaleWithZoom = true,\n          } = child.props;\n\n          if (!markerImage) {\n            return;\n          }\n\n          let coverWidthScale = 1;\n          let coverHeightScale = 1;\n          if (markerImage.width > markerImage.height) {\n            coverHeightScale = markerImage.height / markerImage.width;\n          } else {\n            coverWidthScale = markerImage.width / markerImage.height;\n          }\n\n          const scaledSize = scaleWithZoom ? size : size / scale;\n          const centreX = coords.x;\n          const centreY = coords.y;\n          if (inCircle) {\n            const imageSize = scaledSize * 0.55;\n            const renderWidth = imageSize * coverWidthScale;\n            const renderHeight = imageSize * coverHeightScale;\n\n            context.beginPath();\n            context.arc(centreX, centreY, scaledSize / 2, 0, 2 * Math.PI, false);\n            context.fillStyle = circleColour;\n            context.fill();\n            context.drawImage(\n              markerImage,\n              centreX - renderWidth / 2,\n              centreY - renderHeight / 2,\n              renderWidth,\n              renderHeight\n            );\n          } else {\n            const renderWidth = scaledSize * coverWidthScale;\n            const renderHeight = scaledSize * coverHeightScale;\n            context.drawImage(\n              markerImage,\n              centreX - renderWidth / 2,\n              centreY - renderHeight / 2,\n              renderWidth,\n              renderHeight\n            );\n          }\n        };\n\n        const draggingMarker = getMarkerChild(draggingMarkerKey.current || \"\");\n        markers.current.filter((child) => child !== draggingMarker).map(renderMarkers);\n        if (draggingMarker && dragged.current) {\n          const hoverDropZone = getDropZoneTouchingCursor();\n          const renderDropZones = (child: React.ReactElement) => {\n            const {\n              right,\n              left,\n              top,\n              bottom,\n              width,\n              height,\n\n              label,\n              colour = \"#fff\",\n              backgroundColour = \"#0f0\",\n              fontSize = 24,\n              image: dropZoneImage,\n            } = child.props;\n            const { topLeft, bottomRight, valid } = getScreenPositionCoords({\n              right,\n              left,\n              top,\n              bottom,\n              width,\n              height,\n            });\n            if (!valid) {\n              return;\n            }\n\n            context.globalAlpha = child === hoverDropZone ? 1 : 0.7;\n            context.beginPath();\n            context.fillStyle = backgroundColour;\n            context.fillRect(topLeft!.x, topLeft!.y, bottomRight!.x - topLeft!.x, bottomRight!.y - topLeft!.y);\n            if (dropZoneImage) {\n              context.drawImage(\n                dropZoneImage,\n                topLeft!.x,\n                topLeft!.y,\n                bottomRight!.x - topLeft!.x,\n                bottomRight!.y - topLeft!.y\n              );\n            }\n            context.textAlign = \"center\";\n            context.fillStyle = colour;\n            context.font = `${fontSize / scale}px Arial`;\n            if (label) {\n              context.fillText(\n                label,\n                (bottomRight!.x + topLeft!.x) / 2,\n                (bottomRight!.y + topLeft!.y) / 2 + fontSize / 4 / scale\n              );\n            }\n            context.globalAlpha = 1;\n          };\n          dropZones.current.map(renderDropZones);\n        }\n        markers.current.filter((child) => child === draggingMarker).map(renderMarkers);\n        updateTooltips();\n        updateCursor();\n      },\n      [getDropZoneTouchingCursor, updateCursor]\n    );\n    useEffect(() => {\n      redraw(\"new children\");\n    }, [flatChildren, redraw]);\n\n    const resetView = useCallback(() => {\n      if (!canvasRef.current) {\n        return;\n      }\n      const context = canvasRef.current.getContext(\"2d\");\n      if (!context) {\n        return;\n      }\n\n      const transform = context.getTransform();\n      const maxScale = Math.max(transform.a, transform.d);\n      context.setTransform(maxScale, 0, 0, maxScale, transform.e, transform.f);\n      redraw(\"view reset\");\n    }, [redraw]);\n\n    // scale at which the provided image totally covers the canvas\n    const [containmentScale, setContainmentScale] = useState(1);\n\n    const maxImageZoom = useMemo(() => {\n      if (allowContainmentZoom) {\n        return Math.max(maxZoom, containmentScale);\n      }\n      return maxZoom;\n    }, [allowContainmentZoom, maxZoom, containmentScale]);\n    const minImageZoom = useMemo(() => {\n      if (allowContainmentZoom) {\n        return Math.min(minZoom, containmentScale);\n      }\n      return minZoom;\n    }, [allowContainmentZoom, minZoom, containmentScale]);\n\n    const updateContainmentScale = () => {\n      if (!canvasRef.current || !mapImage.current) {\n        return;\n      }\n      const imgWidth = mapImage.current.width;\n      const imgHeight = mapImage.current.height;\n      if (imgWidth && imgHeight) {\n        const widthScaledHeight = (imgHeight / imgWidth) * canvasRef.current.width;\n        let updatedScale = 1;\n        if (widthScaledHeight > canvasRef.current.height) {\n          updatedScale = canvasRef.current.height / imgHeight;\n        } else {\n          updatedScale = canvasRef.current.width / imgWidth;\n        }\n        setContainmentScale(updatedScale);\n      }\n    };\n    const [imageInitialised, setImageInitialised] = useState(false);\n    const handleImageLoad = useMemo(\n      () => () => {\n        mapImageValid.current = true;\n        if (!canvasRef.current || !mapImage.current) {\n          return;\n        }\n        const context = canvasRef.current.getContext(\"2d\");\n        if (!context) {\n          return;\n        }\n        const imgWidth = mapImage.current.width;\n        const imgHeight = mapImage.current.height;\n        if (imgWidth && imgHeight) {\n          const containing = (!imageInitialised && containInitialImage) || (imageInitialised && containUpdatedImage);\n          const widthScaledHeight = (imgHeight / imgWidth) * canvasRef.current.width;\n          const heightScaledWidth = (imgWidth / imgHeight) * canvasRef.current.height;\n          let newContainmentScale = 1;\n          if (widthScaledHeight > canvasRef.current.height) {\n            newContainmentScale = canvasRef.current.height / imgHeight;\n            if (containing) {\n              let transform = context.getTransform();\n              const scaleAdjust = newContainmentScale / transform.d;\n              context.scale(scaleAdjust, scaleAdjust);\n              transform = context.getTransform();\n              context.translate(\n                (-transform.e + canvasRef.current.width / 2 - heightScaledWidth / 2) / transform.a,\n                -transform.f / transform.d\n              );\n            }\n          } else {\n            newContainmentScale = canvasRef.current.width / imgWidth;\n            if (containing) {\n              let transform = context.getTransform();\n              const scaleAdjust = containmentScale / transform.a;\n              context.scale(scaleAdjust, scaleAdjust);\n              transform = context.getTransform();\n              context.translate(\n                -transform.e / transform.a,\n                (-transform.f + canvasRef.current.height / 2 - widthScaledHeight / 2) / transform.d\n              );\n            }\n          }\n          updateContainmentScale();\n          redraw(\"image load\");\n          if (!imageInitialised) {\n            setImageInitialised(true);\n          }\n        }\n      },\n      [imageInitialised, containInitialImage, containUpdatedImage, redraw, containmentScale]\n    );\n\n    const resize = useCallback(() => {\n      if (!canvasRef.current) {\n        return;\n      }\n\n      if (cursor.current !== null) {\n        const cursorXProportion = cursor.current.x / canvasRef.current.clientWidth;\n        const cursorYProportion = cursor.current.y / canvasRef.current.clientHeight;\n\n        cursor.current = {\n          x: cursorXProportion * canvasRef.current.width,\n          y: cursorYProportion * canvasRef.current.height,\n        };\n        updateMouseCoords();\n      }\n\n      canvasRef.current.width = canvasRef.current.clientWidth;\n      canvasRef.current.height = canvasRef.current.clientHeight;\n\n      // reset the transforms\n      // todo: rescale the transforms to match the new size instead\n      updateContainmentScale();\n      resetView();\n    }, [resetView, updateMouseCoords]);\n    useEffect(() => {\n      window.addEventListener(\"resize\", resize);\n      return () => {\n        window.removeEventListener(\"resize\", resize);\n      };\n    }, [resize]);\n\n    const handleClick = useCallback(() => {\n      const pt = getCursorCoords();\n      if (pt === null) {\n        return;\n      }\n\n      let clickedMarker: React.ReactElement | undefined;\n      if (draggingMarkerKey.current) {\n        clickedMarker = getMarkerChild(draggingMarkerKey.current);\n      }\n      if (clickedMarker) {\n        if (typeof clickedMarker.props.onClick === \"function\") {\n          clickedMarker.props.onClick();\n        }\n      } else if (typeof onClick === \"function\") {\n        onClick(pt);\n      }\n    }, [onClick]);\n    const dragTick = useCallback((markerKey: string) => {\n      const pt = getCursorCoords();\n      if (pt === null) {\n        return;\n      }\n      const draggingMarker = getMarkerChild(markerKey);\n      if (draggingMarker && typeof draggingMarker.props.onDragTick === \"function\") {\n        draggingMarker.props.onDragTick(pt);\n      }\n    }, []);\n    const dragEnd = useCallback(\n      (markerKey: string) => {\n        const pt = getCursorCoords();\n        if (pt === null) {\n          return;\n        }\n        const draggedMarker = getMarkerChild(markerKey);\n        if (!draggedMarker) {\n          return;\n        }\n\n        const droppedZone = getDropZoneTouchingCursor();\n        if (droppedZone) {\n          if (typeof draggedMarker.props.onDragCancel === \"function\") {\n            draggedMarker.props.onDragCancel();\n          }\n          if (typeof droppedZone.props.onDrop === \"function\") {\n            droppedZone.props.onDrop(draggedMarker.props.markerKey);\n          }\n        } else if (typeof draggedMarker.props.onDragEnd === \"function\") {\n          draggedMarker.props.onDragEnd(pt);\n        }\n      },\n      [getDropZoneTouchingCursor]\n    );\n\n    const handleDocumentMouseMove = useCallback(\n      (event: MouseEvent) => {\n        if (!canvasRef.current) {\n          return;\n        }\n        const context = canvasRef.current.getContext(\"2d\");\n        if (!context) {\n          return;\n        }\n\n        const lastPt = getCursorCoords();\n        const rect = canvasRef.current.getBoundingClientRect();\n        if (event) {\n          cursor.current = {\n            x: event.clientX - rect.x,\n            y: event.clientY - rect.y,\n          };\n          updateMouseCoords();\n        }\n\n        if (!clickPoint.current) {\n          updateCursor();\n          return;\n        }\n\n        if (+new Date() > clickTime.current + clickGraceTime) {\n          dragged.current = true;\n        }\n\n        if (draggingMarkerKey.current) {\n          if (typeof clickTime.current === \"number\" && +new Date() > clickTime.current + minDragTime) {\n            dragTick(draggingMarkerKey.current);\n          }\n        } else {\n          const pt = getCursorCoords();\n          if (pt === null || lastPt === null || !mapImage.current) {\n            return;\n          }\n          const transform = context.getTransform();\n          let translateX = pt.x - lastPt.x;\n          let translateY = pt.y - lastPt.y;\n          if (translateX > 0) {\n            const xLimit = rect.width - overpan;\n            if (transform.e > xLimit) {\n              translateX = 0;\n            } else if (transform.e + translateX > xLimit) {\n              translateX = xLimit - transform.e;\n            }\n          } else if (translateX < 0) {\n            const xLimit = -(mapImage.current.width * transform.a) + overpan;\n            if (transform.e < xLimit) {\n              translateX = 0;\n            } else if (transform.e + translateX < xLimit) {\n              translateX = xLimit - transform.e;\n            }\n          }\n          if (translateY > 0) {\n            const yLimit = rect.height - overpan;\n            if (transform.f > yLimit) {\n              translateY = 0;\n            } else if (transform.f + translateY > yLimit) {\n              translateY = yLimit - transform.f;\n            }\n          } else if (translateY < 0) {\n            const yLimit = -(mapImage.current.height * transform.d) + overpan;\n            if (transform.f < yLimit) {\n              translateY = 0;\n            } else if (transform.f + translateY < yLimit) {\n              translateY = yLimit - transform.f;\n            }\n          }\n          context.translate(translateX, translateY);\n          redraw(\"pan\");\n        }\n      },\n      [clickGraceTime, minDragTime, overpan, dragTick, redraw, updateCursor, updateMouseCoords]\n    );\n    useEffect(() => {\n      document.addEventListener(\"mousemove\", handleDocumentMouseMove, false);\n      return () => {\n        document.removeEventListener(\"mousemove\", handleDocumentMouseMove, false);\n      };\n    }, [handleDocumentMouseMove]);\n\n    const handleDocumentMouseUp = useMemo(\n      () => () => {\n        if (dragTimeout.current) {\n          window.clearTimeout(dragTimeout.current);\n        }\n        if (\n          draggingMarkerKey.current &&\n          dragged.current &&\n          typeof clickTime.current === \"number\" &&\n          +new Date() > clickTime.current + minDragTime\n        ) {\n          dragEnd(draggingMarkerKey.current);\n        }\n        draggingMarkerKey.current = null;\n        clickPoint.current = null;\n        dragged.current = false;\n        redraw(\"mouse up\");\n      },\n      [minDragTime, dragEnd, redraw]\n    );\n    useEffect(() => {\n      document.addEventListener(\"mouseup\", handleDocumentMouseUp, false);\n      return () => {\n        document.removeEventListener(\"mouseup\", handleDocumentMouseUp, false);\n      };\n    }, [handleDocumentMouseUp]);\n\n    const handleCanvasMouseDown = useCallback(() => {\n      animationCancel.current = true;\n\n      // @ts-ignore: Old vendor prefixes\n      document.body.style.mozUserSelect = \"none\";\n      document.body.style.webkitUserSelect = \"none\";\n      document.body.style.userSelect = \"none\";\n      clickPoint.current = getCursorCoords();\n      dragTimeout.current = window.setTimeout(handleDocumentMouseMove, minDragTime);\n      clickTime.current = +new Date();\n      dragged.current = false;\n      draggingMarkerKey.current = getMarkerTouchingCursor();\n    }, [minDragTime, handleDocumentMouseMove, getMarkerTouchingCursor]);\n    useEffect(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) {\n        return () => {};\n      }\n      canvas.addEventListener(\"mousedown\", handleCanvasMouseDown, false);\n      return () => {\n        canvas.removeEventListener(\"mousedown\", handleCanvasMouseDown, false);\n      };\n    }, [handleCanvasMouseDown]);\n\n    const handleCanvasMouseUp = useCallback(() => {\n      if (!dragged.current) {\n        handleClick();\n      }\n    }, [handleClick]);\n    useEffect(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) {\n        return () => {};\n      }\n      canvas.addEventListener(\"mouseup\", handleCanvasMouseUp);\n      return () => {\n        canvas.removeEventListener(\"mouseup\", handleCanvasMouseUp);\n      };\n    }, [handleCanvasMouseUp]);\n\n    const zoom = useMemo(\n      () => (clicks: number) => {\n        if (!canvasRef.current) {\n          return;\n        }\n        const context = canvasRef.current.getContext(\"2d\");\n        if (!context) {\n          return;\n        }\n\n        const pt = getCursorCoords();\n        if (pt === null) {\n          return;\n        }\n        context.translate(pt.x, pt.y);\n        let factor = SCALE_FACTOR ** clicks;\n        // limit zoom to given ranges in props\n        const transform = context.getTransform();\n        if (factor > 1) {\n          const maxScale = Math.max(transform.a, transform.d);\n          if (maxScale * factor > maxImageZoom) {\n            factor = maxImageZoom / maxScale;\n          }\n        } else {\n          const minScale = Math.max(transform.a, transform.d);\n          if (minScale * factor < minImageZoom) {\n            factor = minImageZoom / minScale;\n          }\n        }\n        context.scale(factor, factor);\n        context.translate(-pt.x, -pt.y);\n        redraw(\"zoom\");\n      },\n      [maxImageZoom, minImageZoom, redraw]\n    );\n    const handleScroll = useCallback(\n      (event: Event) => {\n        animationCancel.current = true;\n\n        // @ts-ignore\n        let delta = event.deltaY;\n        if (delta) {\n          delta /= 40;\n          // @ts-ignore\n        } else if (event.detail) {\n          // @ts-ignore\n          delta = -event.detail;\n        } else {\n          delta = 0;\n        }\n\n        delta = -delta;\n\n        if (delta) {\n          zoom(delta);\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        return false;\n      },\n      [zoom]\n    );\n    useEffect(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) {\n        return () => {};\n      }\n      canvas.addEventListener(\"DOMMouseScroll\", handleScroll, false);\n      canvas.addEventListener(\"mousewheel\", handleScroll, false);\n      return () => {\n        canvas.removeEventListener(\"DOMMouseScroll\", handleScroll, false);\n        canvas.removeEventListener(\"mousewheel\", handleScroll, false);\n      };\n    }, [handleScroll]);\n\n    const handleDocumentKeyDown = useCallback(\n      (event: KeyboardEvent) => {\n        if (event.which === KEYDOWN_ESCAPE) {\n          if (typeof draggingMarkerKey.current === \"string\") {\n            const draggingMarker = getMarkerChild(draggingMarkerKey.current);\n            if (draggingMarker && typeof draggingMarker.props.onDragCancel === \"function\") {\n              draggingMarker.props.onDragCancel();\n            }\n          }\n          clickPoint.current = null;\n          dragged.current = false;\n          redraw(\"mouse down\");\n        }\n      },\n      [redraw]\n    );\n    useEffect(() => {\n      document.addEventListener(\"keydown\", handleDocumentKeyDown, false);\n      return () => {\n        document.removeEventListener(\"keydown\", handleDocumentKeyDown, false);\n      };\n    }, [handleDocumentKeyDown]);\n\n    const handleDragOver = useCallback(\n      (event: MouseEvent) => {\n        if (!canvasRef.current) {\n          return;\n        }\n        const rect = canvasRef.current.getBoundingClientRect();\n        if (event) {\n          cursor.current = {\n            x: event.clientX - rect.x,\n            y: event.clientY - rect.y,\n          };\n          updateMouseCoords();\n        }\n      },\n      [updateMouseCoords]\n    );\n    useEffect(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) {\n        return () => {};\n      }\n      canvas.addEventListener(\"dragover\", handleDragOver, false);\n      return () => {\n        canvas.removeEventListener(\"dragover\", handleDragOver, false);\n      };\n    }, [handleDragOver]);\n\n    const handleDoubleClick = useCallback(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) {\n        return;\n      }\n      const context = extendContext(canvasRef.current.getContext(\"2d\"));\n      if (!context) {\n        return;\n      }\n\n      let clickedMarker: React.ReactElement | undefined;\n      if (draggingMarkerKey.current) {\n        clickedMarker = getMarkerChild(draggingMarkerKey.current);\n      } else {\n        const hovered = getMarkerTouchingCursor();\n        if (hovered) {\n          clickedMarker = getMarkerChild(hovered);\n        }\n      }\n      if (clickedMarker) {\n        if (typeof clickedMarker.props.onDoubleClick === \"function\") {\n          clickedMarker.props.onDoubleClick();\n        }\n      } else if (cursor.current && typeof onDoubleClick === \"function\") {\n        const pt = context.transformedPoint(cursor.current.x, cursor.current.y);\n        onDoubleClick(pt);\n      }\n    }, [onDoubleClick, getMarkerTouchingCursor]);\n    useEffect(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) {\n        return () => {};\n      }\n      canvas.addEventListener(\"dblclick\", handleDoubleClick);\n      return () => {\n        canvas.removeEventListener(\"dblclick\", handleDoubleClick);\n      };\n    }, [handleDoubleClick]);\n\n    useEffect(() => {\n      mapImageValid.current = false;\n      mapImage.current = new Image();\n      mapImage.current.src = image;\n      mapImage.current.onload = handleImageLoad;\n      redraw(\"new image\");\n    }, [image, handleImageLoad, redraw]);\n    useEffect(() => {\n      if (mapImage.current) {\n        mapImage.current.onload = handleImageLoad;\n      }\n    }, [handleImageLoad]);\n\n    useEffect(() => {\n      resize();\n    }, [resize]);\n\n    const animate = useCallback(\n      (timestamp: number) => {\n        if (animationCancel.current) {\n          animationStart.current = null;\n          animationCancel.current = false;\n          animationActive.current = false;\n          return;\n        }\n\n        if (!canvasRef.current) {\n          // abort and try later\n          window.requestAnimationFrame(animate);\n          return;\n        }\n        const rect = canvasRef.current.getBoundingClientRect();\n        const context = canvasRef.current.getContext(\"2d\");\n        if (!context) {\n          return;\n        }\n        const transform = context.getTransform();\n\n        if (!animationStart.current) {\n          animationStart.current = timestamp;\n          animationLastTimestamp.current = timestamp;\n        }\n\n        const deltaMs = timestamp - animationLastTimestamp.current;\n        animationLastTimestamp.current = timestamp;\n\n        let panDone = true;\n        if (animationCoords.current) {\n          const current = {\n            x: (rect.width / 2 - transform.e) / transform.a,\n            y: (rect.height / 2 - transform.f) / transform.d,\n          };\n          const desired = animationCoords.current;\n\n          const diff = {\n            x: desired.x - current.x,\n            y: desired.y - current.y,\n          };\n          const dist = Math.sqrt(diff.x ** 2 + diff.y ** 2);\n          panDone = dist < 1;\n          if (!panDone) {\n            const delta = Math.min(Math.max(deltaMs * 0.005, 0), 1);\n            context.translate(-diff.x * delta, -diff.y * delta);\n          } else {\n            context.translate(-diff.x, -diff.y);\n            animationCoords.current = null;\n          }\n        }\n\n        redraw(\"animation\");\n\n        animationActive.current = !panDone;\n        if (!panDone) {\n          window.requestAnimationFrame(animate);\n        }\n      },\n      [redraw]\n    );\n    const animatePanTo = useCallback(\n      (coords: Coords) => {\n        animationCancel.current = false;\n        animationStart.current = null;\n        animationCoords.current = coords;\n        if (!animationActive.current) {\n          window.requestAnimationFrame(animate);\n        }\n        animationActive.current = true;\n      },\n      [animate]\n    );\n    useEffect(() => {\n      if (panTo) {\n        animatePanTo(panTo);\n      }\n    }, [panTo, animatePanTo]);\n\n    return (\n      <div\n        style={{\n          position: \"relative\",\n          width: \"100%\",\n          height: \"100%\",\n          overflow: \"hidden\",\n        }}\n      >\n        <canvas\n          ref={(node) => {\n            if (!node) {\n              return;\n            }\n            (canvasRef as React.MutableRefObject<HTMLCanvasElement>).current = node;\n            if (typeof ref === \"function\") {\n              ref(node);\n            } else if (ref) {\n              // eslint-disable-next-line no-param-reassign\n              (ref as React.MutableRefObject<HTMLCanvasElement>).current = node;\n            }\n          }}\n          style={{ width: \"100%\", height: \"100%\" }}\n        />\n        <div ref={tooltipsRef}>{tooltipChildren}</div>\n      </div>\n    );\n  }\n);\n\nexport { Map };\nexport type { MapProps };\n", "interface ExtendedContext extends CanvasRenderingContext2D {\n  transformedPoint(x: number, y: number): DOMPoint\n  untransformedPoint(x: number, y: number): DOMPoint\n}\n\nexport type { ExtendedContext }\n\nexport function extendContext(ctx: CanvasRenderingContext2D | null): ExtendedContext | null {\n  if (!ctx) return ctx\n  const extended = ctx as ExtendedContext\n  extended.transformedPoint = (x: number, y: number) => {\n    const pt = new DOMPoint(x, y)\n    const transform = extended.getTransform()\n    return pt.matrixTransform(transform.inverse())\n  }\n  extended.untransformedPoint = (x: number, y: number) => {\n    const pt = new DOMPoint(x, y)\n    const transform = extended.getTransform()\n    return pt.matrixTransform(transform)\n  }\n  return extended\n}\n", "import React from 'react'\n\nimport type { Coords } from './types'\n\ntype MarkerProps = {\n  markerKey: string\n  coords: Coords\n  image: HTMLImageElement\n\n  inCircle?: boolean\n  circleColour?: string\n  size?: number\n  scaleWithZoom?: boolean\n\n  onClick?(): void\n  onDoubleClick?(): void\n\n  dragZoneScale?: number\n  onDragTick?(coords: Coords): void\n  onDragEnd?(coords: Coords): void\n  onDragCancel?(): void\n}\n\nconst Marker: React.FC<MarkerProps> = () => null\n\nexport { Marker }\nexport type { MarkerProps }\n", "import React from 'react'\n\ntype DropZoneProps = {\n  right?: number\n  left?: number\n  top?: number\n  bottom?: number\n  width: number\n  height: number\n\n  label?: string\n  colour?: string,\n  backgroundColour?: string,\n  fontSize?: number,\n  image?: HTMLImageElement,\n\n  onDrop(markerKey: string): void,\n}\n\nconst DropZone: React.FC<DropZoneProps> = () => null\n\nexport { DropZone }\nexport type { DropZoneProps }\n", "import React from 'react'\nimport classNames from 'classnames'\n\nimport type { Coords } from './types'\n\ntype TooltipProps = {\n  className?: string\n  coords: Coords\n  children: React.ReactNode\n}\n\nconst Tooltip: React.FC<TooltipProps> = ({\n  className,\n  coords,\n  children,\n}) => (\n  <div\n    className={classNames('RCMAP-tooltip', className)}\n    data-x={coords.x}\n    data-y={coords.y}\n  >\n    <span className=\"RCMAP-tooltip-arrow-outer\" />\n    <span className=\"RCMAP-tooltip-arrow-inner\" />\n    <div className=\"RCMAP-tooltip-body\">\n      {children}\n    </div>\n  </div>\n)\n\nexport { Tooltip }\nexport type { TooltipProps }\n"],
  "mappings": "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",
  "names": ["require_classnames", "__commonJSMin", "exports", "module", "hasOwn", "nativeCodeString", "classNames", "classes", "i", "arg", "argType", "inner", "key", "React", "useRef", "useState", "useMemo", "useCallback", "useEffect", "extendContext", "ctx", "extended", "x", "y", "pt", "transform", "Marker", "DropZone", "import_classnames", "React", "Tooltip", "className", "coords", "children", "classNames", "SCALE_FACTOR", "KEYDOWN_ESCAPE", "Map", "React", "image", "children", "onClick", "onDoubleClick", "onCursorMove", "minZoom", "maxZoom", "overpan", "minDragTime", "clickGraceTime", "containInitialImage", "containUpdatedImage", "allowContainmentZoom", "panTo", "ref", "canvasRef", "useRef", "mapImage", "mapImageValid", "dragged", "draggingMarkerKey", "dragTimeout", "clickPoint", "clickTime", "cursor", "updateMouseCoords", "useCallback", "context", "extendContext", "animationActive", "animationCancel", "animationStart", "animationCoords", "animationLastTimestamp", "markers", "dropZones", "flatChildren", "useMemo", "allChildren", "getChildren", "child", "asElement", "Tooltip", "Marker", "getMarkerChild", "key", "DropZone", "tooltipChildren", "getCursorCoords", "getScreenPositionCoords", "right", "left", "top", "bottom", "width", "height", "rect", "topLeft", "bottomRight", "getDropZoneTouchingCursor", "pt", "droppedZone", "dropZone", "valid", "getMarkerTouchingCursor", "close", "cursorPt", "markerKey", "coords", "size", "scaleWithZoom", "onMarkerClick", "onMarkerDoubleClick", "dragZoneScale", "onDragTick", "onDragEnd", "HOVER_DIST", "HOVER_DIST_SQ", "distSq", "beaconScreenPt", "closestDist", "closest", "updateCursor", "tooltipsRef", "updateTooltips", "canvasRect", "domChild", "tooltipX", "tooltipY", "screenCoords", "relativeX", "relativeY", "lastRedraw", "logRedraw", "reason", "redraw", "p1", "p2", "scale", "renderMarkers", "markerImage", "inCircle", "circleColour", "coverWidthScale", "coverHeightScale", "scaledSize", "centreX", "centreY", "imageSize", "renderWidth", "renderHeight", "draggingMarker", "hoverDropZone", "renderDropZones", "label", "colour", "backgroundColour", "fontSize", "dropZoneImage", "useEffect", "resetView", "transform", "maxScale", "containmentScale", "setContainmentScale", "useState", "maxImageZoom", "minImageZoom", "updateContainmentScale", "imgWidth", "imgHeight", "widthScaledHeight", "updatedScale", "imageInitialised", "setImageInitialised", "handleImageLoad", "containing", "heightScaledWidth", "newContainmentScale", "scaleAdjust", "resize", "cursorXProportion", "cursorYProportion", "handleClick", "clickedMarker", "dragTick", "dragEnd", "draggedMarker", "handleDocumentMouseMove", "event", "lastPt", "translateX", "translateY", "xLimit", "yLimit", "handleDocumentMouseUp", "handleCanvasMouseDown", "canvas", "handleCanvasMouseUp", "zoom", "clicks", "factor", "minScale", "handleScroll", "delta", "handleDocumentKeyDown", "handleDragOver", "handleDoubleClick", "hovered", "animate", "timestamp", "deltaMs", "panDone", "current", "desired", "diff", "animatePanTo", "node"]
}
